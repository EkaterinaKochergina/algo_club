# Порция 1
* базовые типы
 * int, float, str, bool
 * type - узнать тип
 * операции
   * + - / * **
   * << >> & |
   * and or not
* переменные 
 * a=3:
    * завести область памяти в которой лежит 3
    * связать с переменной a
 * a=b работает по-разному:
    * перепривязка переменной a, если тип b сложный
    * перекладывание данных, если в b - простой тип

## задачи
1. поменять местами значения a и b, можно использовать третью переменную
2. поменять a и b местами без третьей переменной
3. посчитать разные выражения: `2*3+4*5   3**2+4**2    5**2  и т.д .`
    
# Порция 2
* Оператор for
  * Пишется: 
      `for переменная in итерабле:
           тело цикла`
    * итерабле - коллекция, или итератор    
  * читается:
    * выполнять "тело цикла", помещая в "переменную" последовательно все значения из "итерабле"
* Оператор while
  * Пишется:
      `while условие:
           тело цикла`
  * Читается:
    * выполнять "тело цикла", пока выполняется "условие".
 
## задачи
1. Распечатать первые 10 степеней двойки
2. Распечатывать степени двойки, пока они меньше 5000
3. Распечатать первые 15 чисел Фибоначчи
4. Распечатывать числа Фибоначчи, пока они меньше 10000
 
# Порция 3

* Оператор if
  * Пишется: 
      `if условие:
           блок1
       else:
           блок2`
  * Это основная форма. Ещё нужно почитать документацию по поводу elif
* Условие: 
  * элементарные условия: a == b, a < b, a <= b
  * правила построения сложных условий
    * усл1 and усл2
    * усл1 or усл2
    * not усл

## задачи
1. Заданы числа a, b - целые, от -10 000 до 10 000. Решить уравнение a*x + b = 0. Если решений нет, или их бесконечно много, сообщить об этом.
2. Заданы числа a, b, c - целые, от -10 000 до 10 000. Решить уравнение a*x**2 + b*x + c = 0. Если решений нет, или их бесконечно много, сообщить об этом.
3. Написать программу, которая распечатывает числа от 1 до 100. Но если число делится на 3 напечатать вместо него "Fizz", "Buzz" - для делящихся на 5. Вместо чисел, делящихся и на 3 и на 5 напечатать "FizzBuzz".
 
# Порция 4
* Арифметические операции
  * + - / // *
* Логические операции
  * & | ^
  
## задачи
1. Посчитать количество 1 в двоичном представлении целого числа
2. Является ли позиция, заданная массивом целых чисел, выигрышной в игре Ним?
3. В массиве натуральных чисел n пар чисел и одно непарное. Найти это непарное число. Числа идут в произвольном порядке.
4. В массиве натуральных чисел n пар чисел и два непарных. Найти эти непарные числа. Числа идут в произвольном порядке.
5. Является ли число степенью двойки?
6. Является ли число степенью четвёрки?
 
# Порция 5
* Питоновский модуль turtle:
  * команды: turtle.forward() - двигает курсор на заданое число пкселей вперед;
    turtle.backward() - двигает курсор на заданное число пикселей назад;
    turtle.left(), turtle.right() - поворачивает курсор налео или навпрво на заданый угол;
    turtle.circle() - рисует окружность;
    turtle.begin_fill(), turtle.end_fill() - заливка фигуры; 
    turtle.color() - выбор цвета линии;
    turtle.home() - возвращает курсор в точку старта, заданая точка старта имеет координаты (0, 0), но их можно изменить;
    turtle.setposition() or .setpos() and .goto() - задают позицию для старта;
    turtle.clear() - удаляет рисунок с экрана;
    turtle.reset() - возвращает модуль к базовым настройкам и стирает рисунок.
Питоновская база - цикл for, рекурсии
* Пример программы: 
 1. выведет на экран прямоугольник с черной заливкой, длина каждой стороны прямоугольника - 50 пикселей
   import turtle
   turtle.begin_fill()
   for t in range(4):
     turtle.forward(50)
     turtle.left(90)
   turtle.end_fill()
  2.  рекурсивная функция, которая построит сторону звёздочки Коха   
    def f(n,l):
      if n==0:
        turtle.forward(l)
        return
    f(n-1, l/3)
    turtle.left(60)
    f(n-1, l/3)
    turtle.right(120)
    f(n-1, l/3)
    turtle.left(60)
    f(n-1, l/3)
    
 # Задачи
## Про списки и множества
Множество чисел задаётся строкой вида '1,3,5-15,20,21'. Сделать набор функций, позволяющих выполнять операции над множествами: объединение, пересечение, разность множеств, проверка равенства двух множеств. Результат также должен быть в этом формате. Например ls_intersect('7-12,13-20', '10-15') == '10-12,13-15'. ls - list set
## Чтобы разобраться с побитовыми операциями:
 * Распечатать степени двойки от 1ой до 10ой
 * Распечатать двоичные представления степеней двойки
 * По-применять побитовые операции << >> & | ^ к степеням двойки, посмотреть на двоичные представления получившихся результатов. По результатам
 экспериментов выписать таблицы истинности этих операций   
    
 # Геометрическая математика
 (x, y) = p - точка
 
 ## Как разобраться со скалярным и векторным произведениями
 * Написать функции:
   * sum(p1, p2) - покоординатно сложить точки
   * mul(p, k) - каждую координату точки p умножить на число k
   * line(p1, p2, c) - нарисовать отрезок цвета c, соединяющий точки p1, p2
   * shift(p, c) - от текущего положения сдвинуться в направлении p, нарисовать отрезок цвета c
 * Сложение векторов
   * Задать какие-то точки p1, p2
   * Найти p3 = sum(p1, p2)
   * Выполнить действия
     * home -> сдвинуться на p1, красный -> сдвинуться на p2, синий
     * home -> сдвинуться на p3, чёрный
  * Все точки отрезка:
    * $\alpha\cdot p_{11} + (1-\alpha)\cdot p_{12}$
    * Задать какие-нибудь p11, p12. Построить несколько точек по этой формуле, убедиться что все лежат на отрезке p11, p12.
  * Свойства скалярного и векторного произведений
    * определить функции:
      * dot((x1, y1), (x2, y2)) = x1*x2 + y1*y2
      * cross((x1, y1), (x2, y2)) = x1*y2 - x2*y1
    * Взять какие-нибудь x, y, построить вектора:
      * p = (x, y)
      * p1 = (-y, x)
      * p2 = p * k, где k - какое-нибудь число, например 3
    * Нарисовать вектора p, p1, p2 разными цветами. Осознать геометрический смысл умножения на число, замены местами координат с инверсией знака
    * Посчитать:
      * dot(p, p1)
      * cross(p, p1)
      * dot(p, p2)
      * cross(p, p2)
    * Осознать когда обнуляется скалярное произведение, когда - векторное
  * Применить все эти знания для нахождения точки пересечения двух отрезков:
    * Хотим написать функцию intersect(p11, p12, p21, p22) которая рисует отрезки p11-p12 и p21-p22, рассчитывает координаты точки пересечения и ставит туда отметку
    * Идея расчёта точки пересечения:
      * Утверждение раз: точка пересечения p = alpha * p11 + (1-alpha)*p12 лежит на  отрезке p11-p12
      * Утверждение два: нужно сделать alpha таким что векторное произведение p - p21 и p22 - p21 должно равняться нулю
      * По известной alpha находим точку - профит
 
 # Геометрический смысл скалярного произведения
   * Взяли произвольный вектор e11
   * По нему посчитали параллельный единичный вектор e1. Для этого:
     * определить функцию norm, находящую модуль вектора
     * умножить e1 на его обратную длину
   * e2 - повёрнутый против часовой стрелки на 90 градусов e1
   * Взяли произвольный вектор p
   * посчитали px = (p, e1), py = (p, e2)
   * Нарисовать вектора: p, p1 = e1 * px, p2 = e2 * py, p3 = p1 + p2
   * Построить картинки для нескольких значений e11, p. Дивиться результату.
   
 # Геометрический смысл знака векторного произведения
   * Нарисовать векторы p1 = (100, 10), p2 = (100, 20), p3 = (100, 30), p4 = (100, 40)
   * Посчитать векторные произведения пар этих векторов
   * Догадаться до геометрического смысла знака векторного произведения
   
 # Черепашка в квадрате
   * В цикле прибавлять к (x, y) приращения (dx, dy). Каждый раз двигать черепашку в точку (x, y)
   * Если в следующий момент выходим из квадрата со стороной 100, меняем знак приращения dx или dy (по которому выходим)
 
    
 # Почитать
 
 * [Курс для школьников](http://informatics.mccme.ru/course/view.php?id=156)
 * [Курс на сайте mccme](http://informatics.mccme.ru/) - Тыкаем на "изучение языка программирования". Дальше выбираем один из разделов "ввод-вывод", "условный оператор", "операторы цикла" и т.д. Внутри заходим в раздел "Теоретический материал: Python"
 * [думать как програмёр. Черепашки](http://www.openbookproject.net/thinkcs/archive/python/thinkcspy3e_abandoned/ch03.html)
